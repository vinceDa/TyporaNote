## 什么是数据结构与算法

数据结构是一组数据的存储结构，算法是操作数据的一组方法；那为什么要将他们放在一起说呢？这是因为数据结构和算法是相辅相成的，数据结构是服务于算法的，算法需要作用于特定的数据结构上；所以我们无法忽视数据结构来单独讲算法，反之亦然。

比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但如果我们选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。

我们说了数据结构是一组数据的存储结构，如果我们不在这个存储结构上做操作、构建算法，那它就是没用的。

## 为什么要学习数据结构与算法

### 为了通过大厂面试

首先，针对在校大学生来说，校招是他们进入大厂的重要途径。而在校学生往往没有什么项目经验，所以大厂主要会考察他们的基础知识。这时候数据结构和算法往往是考察的重点，因为客观来说了解数据结构与算法意味着一个人的长期潜力是值得挖掘的。而对于项目经验丰富的打工人来说，熟悉数据结构与算法更是一个加分项，在我看来，数据结构与算法是一个长期学习的过程，所以它也能反映你在日常时间的一个学习状态。

### 跳出舒适圈

都说面试造火箭，入职拧螺丝。确实，进入公司之后，我们面对的更多是业务逻辑方面的问题，很少会有底层的难点等着我们去突破。这时候，我们就会陷入一个舒适圈，久而久之就会成为网上贩卖焦虑文章中的一员（35岁被淘汰）。学习算法，可以让我们保持一个长期学习的状态，跳出舒适圈。

<img src=".\pic\舒适圈.jpg" alt="舒适圈" style="zoom:33%;" />

### 成为一个合格的技术大牛

举个例子：Java中HashMap的负载因子是什么，为什么默认是0.75？出现哈希碰撞后为什么使用链地址法而不是开放定址法或其他？区别是什么？链表超过一定长度后为什么会转为红黑树？等等。。

我相信只要系统学完数据结构与算法，上面的这些问题你一定会有很深刻的理解。它能够帮助我们更好的理解源码，了解其中的实现思想，在它的影响下我们在不久的将来也会成为一个能够写出开源项目级别源码的人！

> 总而言之，为了钱！

<img src=".\pic\我出来打工.jpg" alt="我不惦记钱我惦记什么"/>

## 复杂度分析

我们知道，数据结构和算法主要的特点就是执行效率快、占用空间小。所以，执行效率是算法的一个重要考核指标。而我们通常会根据“快”和“省”这两个特点将执行效率分析分为时间复杂度分析和空间复杂度分析两种。

### 为什么要进行复杂度分析

我们通常的做法就是代码写出来后将代码跑起来，然后通过统计、监控等方式来判断代码的执行效率，这种方式叫**事后统计法**。但是事后统计法有几个较大的局限：

1. 测试结果非常依赖测试环境
2. 测试结果受数据规模的影响很大
3. 测试数据的设计非常困难

既然事后统计法有这么大的局限，所以我们需要一种不依赖测试环境和测试数据的算法，也是我们需要重点了解的事前分析估算法。

在了解事前分析估算法之前，我们需要了解大 O 时间复杂度表示法：[算法](https://baike.baidu.com/item/算法/209025)的时间复杂度通常用[大O符号](https://baike.baidu.com/item/大O符号)表述，定义为
$$
T[n] = O(f(n))
$$
其中，f(n)表示执行次数，T[n]表示执行所需时间，它描述的是执行次数与执行时间的关系，表示代码执行时间随数据规模增长的变化趋势。所以，大 O 时间复杂度表示法也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

### 时间复杂度分析

上面我们了解了时间复杂度的由来和表示形式，接下来我们通过例子来介绍几种分析方法。

> 前提：假设每一行代码的执行时间都是固定的。

1. 只关注执行循环次数最多的代码

   ```java
   int getSum(int n) {
       int sum = 0;
       int i = 0;
       for (; i < n; i++) {
           sum += i;
       }
       return sum;
   }
   ```

   在这个例子中，第2、3行代码的执行时间都是常量级，而for循环的执行时间随着n的变化而变化，此时T(n) = 1 + 1 + O(n)；当n无限大时，常量级的数据可以忽略不计，所以当前代码的时间复杂度为T(n) = O(n)。

2. 乘法法则：嵌套代码的时间复杂度等于嵌套层内外的代码复杂度的乘积

   ```java
   int getSum(int n) {
       int sum = 0;
       int i = 0;
       for (; i < n; i++) {
           sum += i;
       	int j = 0;
           for (; j < n; j++) {
               sum += j;
           }
       }
   }
   ```

   在这个双循环的例子中，外部循环每执行一次，内部循环都会执行n次，所以这段代码的时间复杂度为$T(n) = O(n * n) = o(n^2)$。
   
3. 加法法则：总复杂度等于量级最大的那段代码的复杂度

   ```java
   int getSum(int n) {
       int sum = 0;
       int i = 0;
       int m = 0;
       
       for (; m < n; m++) {
           sum += m;
       }
       
       for (; i < n; i++) {
           sum += i;
       	int j = 0;
           for (; j < n; j++) {
               sum += j;
           }
       }
   }
   ```

   这个例子在上面的代码中新增了一段for循环，此时的时间复杂度为O(n) + O(n * n)，当n无限大时，O(n)在O(n * n)面前可以忽略不计，所以最终这段代码的时间复杂度为$T(n) = O(n) + O(n * n) = o(n^2)$。

这几种是时间复杂度分析中最常见的几个，针对以上几种情况我们可以总结一下时间复杂度的分析方法：忽略掉常量、低次幂和最高次幂的系数。

#### 时间复杂度实例

1. $O(1)$

   ```java
   int sum = 0;
   sum += n;
   ```

2. $O(log^n)$

   ```java
   int i = 1;
   while (i < n) {
       i = i * 2;
   }
   ```

   这时候i的取值为 $1、2^1、2^2、2^3...2^x = n $，这就是一个等比数列，通过$2^x = n$可以得知$x=log^n$，所以这段代码的时间复杂度就为$O(log^n)$。

3. $O(n^k)$

   ```java
   int i = 0;
   ...
   for (; i < n; i++) {
   	int j = 0;
       for (; j < n; j++) {
   		int k = 0;
           for (; i < n; k++) {
   			sum += k;
           }
           ...
   	}
   }
   ```

   随着for循环的层级累加(平常肯定不会这么写...)，这个代码的时间复杂度为$O(n^k)$，k表示嵌套层级。

4. $O(m + n)、O(m * n)$

   ```java
   int i = 0;
   for (; i < n; i++) {
       sum += n;
   }
   
   for (; i < m; i++) {
       sum += m;
   }
   ```

   由于m和n属于不同的量级，所以这里的时间复杂度并不能根据量级高的那段代码去评定，所以这段代码的时间复杂度应该是两段代码之和：$O(m + n)$。

   ```java
   for (int i = 0; i < m; i++) {
       i = 0;
       for (int i = 0; i < n; i++) {
       	sum += n;
   	}
   }
   ```

   虽然这里m和n不是一个量级，但是这段代码的时间复杂度是$O(m) * O(n) = O(m * n)$，这和$O(n * n) = O(n^2)$并没有什么不同，所以在这里乘法法则同样适用。

#### 其他时间复杂度

1. 最好时间复杂度
2. 最坏时间复杂度
3. 平均时间复杂度
4. 均摊时间复杂度



### 空间复杂度分析

空间复杂度表示算法的存储空间与数据规模之间的增长关系。对于空间复杂度而言，对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，只要能掌握之前的时间复杂度分析，自然就会分析空间复杂度了。

## 小结


